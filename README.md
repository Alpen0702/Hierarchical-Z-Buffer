# Hierarchical Z-Buffer
这里是2022秋-计算机图形学的课程作业：使用扫描线z-buffer和层次z-buffer算法实现深度消隐。<br><br>
## 程序结构
为了比较各种消隐算法的效率，并且将各算法明显区分开来方便阅读，本项目基本将每个算法的代码各自放置于一个源文件中。<br><br>
`main.cpp`是本项目的主程序。在主程序中，首先选择用于测试的OBJ模型。在这里，我们准备了四个大小不同的模型供选择，默认使用`hut_t.obj`。选择模型后，主程序会调用`readOBJ.cpp`和`adjustOBJ.cpp`来读取OBJ文件，并将其调整到与窗口合适的大小。<br><br>
完成OBJ文件的读取和调整后，主程序将对OpenGL进行初始化，然后依次调用四个深度消隐函数来实现不同算法对模型的消隐和呈现。每个深度消隐函数都会创建一个新的图形窗口，并以线框图的形式显示其渲染结果。关闭上一个图形窗口后，下一个深度消隐函数才会开始运行。（本来是想同时在一个窗口中分屏显示四个深度消隐函数的结果的，但考虑到要比较fps，故让机器每次专注于一个算法，然后依次显示）<br><br>
四个深度消隐函数都结束后，主程序会调用`summary.cpp`来生成一份总结报告，包括每个深度消隐函数的运行时间、绘制帧数和fps。可以利用这些数据来计算不同算法间的加速比。<br><br>
下面是主程序调用的四个深度消隐函数的主要结构及功能概述：<br><br>
### 不使用z-buffer
`NoneZBuffer.cpp`是第一个运行的渲染子程序。它会建立一个"None Z-Buffer"窗口，并显示不使用任何消隐算法、而是直接绘制面片的渲染结果。因此，其渲染出的线框图会出现前后相互重叠的现象。<br><br>
具体而言，渲染函数首先将背景铺为白色，然后调用`NrasterizeTriangle()`函数遍历面片；在每个面片中，又调用`NrasterizeLine()`函数，从每条线段的上端点到下端点遍历y值，并依照斜率计算对应的x值，以逐行进行光栅化。<br><br>
编写这个子程序的目的是计算基本的旋转模型、绘制缓冲区所需要的时间，为其他消隐算法提供对照。<br><br>
### 扫描线z-buffer
`ScanlineZBuffer.cpp`是第二个运行的渲染子程序。它会建立一个"Scanline Z-Buffer"窗口，并显示使用扫描线z-buffer算法消隐后得到的渲染结果。<br><br>
扫描线z-buffer算法会在每一帧的开头调用`genTables()`函数，根据边和三角形面片的最大y值来建立分类边表、三角形表和活化边表。然后，它会从最大的y值开始逐行向下扫描，将扫描到的新三角形中的边加入活化边表，然后利用面片的连续性，增量式地计算出同一行下一个x值处的面片深度，并依次更新深度缓冲实现消隐。随着扫描线的推进，过期的三角形面片和边会从活化表中移除。由于每次只会进行一行像素的渲染，因此其深度缓冲区可以不使用二维数组而是使用一维数组，从而节省空间。<br><br>
不过，在实际的编程操作中，我们发现，对边和三角形建表后逐行扫描对时间的消耗很大，而其使用一维数组节省的空间对于正常尺寸的显示屏而言并不算重要。在本项目中，主要的限制因素是时间而非空间。因此，在version 1.1以后的`ScanlineZBuffer.cpp`中，我们舍弃了建表逐行扫描的办法，而是选择对每个三角形面片直接进行扫描。具体而言，在`SrasterizeTriangle()`函数中，我们将每个三角形横切为上下两个小三角形，小三角形均为平顶或平底，方便扫描线运作。然后，与原方法类似地光栅化上下两个小三角形，并将深度信息存储到二维而非一维的深度缓冲区中，如此遍历每个三角形面片，以获得整体的光栅化结果。<br><br>
当前的`ScanlineZBuffer.cpp`中，仍在注释中保留了一维深度缓冲的经典扫描线z-buffer算法以供参考。您也可以查看项目历史版本中的首次提交以查阅经典扫描线z-buffer算法的实现。<br><br>
### 简单层次z-buffer
`BaselineHierarchialZBuffer.cpp`是三个运行的渲染子程序。它会建立一个"Baseline Hierarchial Z-Buffer"窗口，并显示使用简单层次z-buffer算法消隐后得到的渲染结果。简单层次z-buffer使用了四叉树结构，及时去除被四叉树结点完全遮挡的面片。它与完整的层次z-buffer之间的区别在于：简单层次z-buffer没有使用八叉树来剖分空间。<br><br>
在开始渲染前，程序会调用`buildQuadTree(Node* father, int level, int l, int r, int d, int u)`来建立一棵四叉树。本项目中建立的四叉树是以整数int作为边界的，左闭右开，下闭上开。建立四叉树前，可以选择所建四叉树的最大深度，也可以选择建立到底层以单个像素作为叶子结点。建树的操作只需要进行一次，不需要每一帧重建，只需要每一帧清空深度即可。<br><br>
在`Bmain()`中，对每个三角形面片，都要先找到能包含该面片的最小四叉树结点。对标准网格切割的四叉树而言，只要结点包含三角形的三个顶点，就一定能完全覆盖整个三角形面片。这里，我们对三个顶点采用自下而上寻找最小公共祖先的方式来实现。<br><br>
找到作为最小公共祖先的四叉树结点后，通过比较三角形的深度和四叉树结点的深度，我们就可以筛选出一些比四叉树结点还要深的三角形面片免于光栅化，从而提升效率。这也是层次z-buffer算法的主要思想。后续光栅化使用`BrasterizeTriangle(Vertex* v1, Vertex* v2, Vertex* v3)`实现，流程与扫描线z-buffer的实现方法类似，但要注意更新四叉树结点的深度。<br><br>
### 层次z-buffer
`HierarchialZBuffer.cpp`是最后一个运行的渲染子程序。它会建立一个"Hierarchial Z-Buffer"窗口，并显示使用完整的层次z-buffer算法消隐后得到的渲染结果。完整的层次z-buffer比Baseline更加复杂，主要在于它使用了八叉树剖分空间，并将面片分配到八叉树结点中，从而免去被四叉树节点完全遮挡的八叉树结点中的面片的渲染。<br><br>
与简单层次z-buffer的过程基本类似地，完整的层次z-buffer需要在开始渲染前建立四叉树和八叉树，在每一帧结束后清空四叉树和八叉树。在每一帧中，需要调用`insertTriangleToOctNode(OctNode* octNode, int triangleID)`函数来将三角形面片插入到八叉树中，如果八叉树结点中含有的面片太多，还需要调用`splitOctNode(OctNode* octNode)`来继续分割。<br><br>
事实上，判断三角形与八叉树包围盒的相交关系也是一个较为复杂的过程。我们使用了`isTriangleCrossOctNode(OctNode* octNode, int triangleID)`、`isEdgeCrossOctNode(OctNode* octNode, Vertex* v1, Vertex* v2)`、`isEdgeCrossRectangle(Vertex* v1, Vertex* v2, int Ndir, float dist, float min1, float max1, float min2, float max2)`、`isVertexInOctNode(OctNode* octNode, Vertex* vertex)`等四个函数来实现了这一功能，具体实现请参阅这段代码。<br><br>
在渲染时，完整的层次z-buffer不会遍历三角形面片，而是从八叉树的根结点开始，遍历树的子结点来绘制其中包含的面片。这一操作由`drawOctNode(OctNode* octNode, QuadNode* quadNode)`来完成。
<br><br><br><br>
需要指出的是，以上四个消隐子程序都并非直接使用OpenGL绘制线段和面片，而是将需要绘制的像素的RGB信息存储在`pixels[][]`数组中，待一帧中的所有面片消隐全部结束后，再将`pixels[][]`数组投射到一个正方形的布满屏幕的纹理上，最后一次性在屏幕上绘制一个带有该纹理的布满屏幕的正方形，从而实现延迟渲染。<br><br>
此外，在深度消隐的每一帧，消隐函数都会调用`adjustOBJ.cpp`中的`rotate`函数，将模型进行旋转。注意，视点始终没有改动。<br><br>
## 使用说明
本项目是在Windows11环境下用Visual Studio 2022开发的，主要调用的外部库仅为GL/freeglut.h。<br><br>
下载项目zip文件并解压后，用Visual Studio运行`Hierarchical Z-Buffer.sln`即可进行调试和编译。如果运行失败，请联系我获得支持；你也可以在根目录下直接打开`Hierarchical Z-Buffer.exe`来查看项目运行结果，无需自行编译。**但请确保项目使用的OBJ格式文件处于原位不要移动。**<br><br>
在开始运行前，你可以找到`main.cpp`中的`// 选择模型`处，在这里指定不同的路径以选择不同的模型来展示。提供的OBJ模型包括：<br><br>
- cubes.obj     八个缺面的立方体，含64个顶点，80个面片
- teapot.obj    犹他茶壶，含4658个顶点，9216个面片
- hut_t.obj     一所小房子，含43788个顶点，85644个面片
- house_t.obj   一个庭院，含58226个顶点，110560个面片<br><br>
你也可以添加自己的OBJ格式文件。不过，由于我一开始以为OBJ格式全是三角形的（！！！）所以我的读入格式设置为
```
v 1 1 1
v 2 2 2
v 3 3 3
f 1/0/0 2/0/0 3/0/0
```
<br>
符合这个格式就行。项目运行时，首先弹出红色线框显示的"None Z-Buffer"窗口，同时在命令行界面显示绘制的fps。你可以在运行一段时间后关闭图形窗口，**注意，是关闭图形窗口，而非关闭命令行界面。**<br><br>
![演示](https://github.com/Alpen0702/CADProject/blob/master/%E6%BC%94%E7%A4%BA.gif)<br><br>
关闭图形窗口后，项目会自动切换到下一个子程序，弹出新的图形窗口，依次是黄色线框显示的"Scanline Z-Buffer"、蓝色线框显示的"Baseline Hierarchial Z-Buffer"和绿色线框显示的"Hierarchial Z-Buffer"。关闭最后一个图形窗口后，命令行界面将会生成一份总结报告，可以参阅不同消隐函数的运行时间、渲染帧数和fps等数据。<br><br>
## 讨论与反思
运行过我的代码就会知道为什么我在summary里面没有把加速比写出来了（其实fps都算出来写在那儿了，加速比一目了然），因为在这几个OBJ模型中，完整和简单的层次z-buffer算法都没比扫描线z-buffer算法好到哪儿去。<br><br>
完整的层次z-buffer尤其慢。我在分步debug的时候测试了它的耗时，发现分割八叉树没有我想得那么慢，但是`insertTriangleToOctNode(OctNode* octNode, int triangleID)`和`drawOctNode(OctNode* octNode, QuadNode* quadNode)`，也就是将三角形插入到八叉树结点中、以及绘制八叉树结点中的面片这两个过程特别耗时。在使用`hut_t.obj`时，每一帧中这两个过程分别用时1.5s和0.3s，这个速度是完全不能接受的。造成这个结果，我认为一方面是我的代码可能还有地方可以改进，另一方面是八叉树的递归操作实在太复杂了，如果没有硬件加速分布式运算，而是只用CPU去跑单线程，那真的会是慢慢慢（如果别人这样写很快那当我没说）。<br><br>
至于我的简单层次z-buffer，其实效果还可以，基本上不会比扫描线z-buffer的结果差，多面片的情况下有时是要略好于扫描线z-buffer的，不过也没有达到我对这个算法的预期。看来看去，我觉得可能还是这个算法的场景太理想了。现实中我用的四个OBJ模型其实就算面片多，也没有很多次的重叠。就以犹他茶壶为例吧，虽然它有近一万个面片，但实际上每个面片都相当小，而且大部分是围成一个圆柱形形成茶壶的侧面的，而茶壶的侧面基本上一个面片只会遮挡住它后面对侧的另一个面片，相当于就算使用了四叉树结构，最理想的情况下也只是节省一半的渲染时间而已，但面片和四叉树结点的相互作用和更新又需要额外的时间，所以总体下来就不一定划算了。<br><br>
关于使用层次z-buffer而免于渲染的面片占全部面片的比例，我在`BaselineHierarchialZBuffer.cpp`中探索过，详情可以参考`Bmain()`中的代码注释。当设置四叉树极限深度为7层，分辨率设置为720\*720时，大概只有不到20%的面片可以因为深度大于四叉树结点而免于渲染。事实上，如果将分辨率调小到72\*72，在渲染`hut_t.obj`的时候简单的层次z-buffer就可以比扫描线z-buffer显著优越了，而且能有超过40%的面片免于被渲染（如下图所示）。<br><br>
![演示](https://github.com/Alpen0702/CADProject/blob/master/%E6%BC%94%E7%A4%BA.gif)<br><br>
这个项目也给我带来了一些收获。加深对各种z-buffer的理解就不说了，主要是让我体会到做渲染对细节真的要求很高。之前听说一些工程师为了速度快一点就自己手写库、位运算balabala的，还不以为意，觉得这样千辛万苦搞来搞去，速度也就提升一点点，没什么必要。因为我之前做OI的时候，基本不会在意常数级别的优化，0.05s Accepted 和 0.03s Accepted 没什么区别。这次改代码的时候我才意识到，逐帧渲染就是会把这些小如0.02s的差距放大：0.05s一帧就是20fps，但0.03s一帧就能有33fps。所以常数级别的优化也会相当重要。在优化`ScanlineZBuffer.cpp`和`BaselineHierarchialZBuffer.cpp`的时候，我就是通过将建树递归的层数减少一层，或是将vector、set等容器改为数组，就提升了一倍的fps。所以日后做渲染的时候还是要注意一些细节的优化，把时间能省尽省。<br><br>
不过，这个项目做到这里还是有一些遗憾。主要是没时间改完整版的层次z-buffer了——**主要是我忘记应用几何造型基础的ddl是今天了OMG**我本来以为是1.13交应用几何造型基础的然后想把z-buffer今天解决然后剩两天火速做一下那门课的十页读书报告，现在看来z-buffer是绝对没时间再改了，文档也没时间再细写了——其实细改一下，我觉得完整版的层次z-buffer至少应该能达到简单版的水平。以后有时间再说吧（挖坑<br><br>
## 联系作者
代码几乎全是自己照着冯老师的ppt手写的，没用什么乱七八糟的库，连Reference都没怎么参考（所以才写得那么烂吧QAQ），不过要特别感谢ChatGPT在debug中对我的帮助。有任何问题，欢迎通过llzju@zju.edu.cn联系我。<br><br>
